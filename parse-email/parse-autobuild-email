#!/usr/bin/python

import os
import sys
import mailbox
import argparse
import re
import requests
import errno
import collections
import time

import config
from email_utils import filter_by_date, count_lines, draw_histogram
from email_utils import recurring_errors, draw_runtime_histogram, errors_since

BASE_CACHE = os.path.join(os.path.dirname(__file__), 'cache/sn-devel/')
STDERR_CACHE = os.path.join(BASE_CACHE, 'stderr')
STDOUT_CACHE = os.path.join(BASE_CACHE, 'stdout')
FLAKEY_LOG_CACHE = os.path.join(BASE_CACHE, 'flakey_log')


def get_cvs_email():
    mbox = mailbox.mbox(config.MAILBOX)
    subj_match = re.compile(r'autobuild[\w\[\].-]*: '
                            'intermittent test failure detected').match
    messages = [x for x in mbox if
                subj_match(x.get('Subject'))]

    return messages


def get_cvs_links():
    messages = get_cvs_email()
    urlre = re.compile(r'http[s]?://git.samba.org/autobuild.flakey[\w.-]*/'
                       '\d\d\d\d-\d\d-\d\d-\d+/[\w.-]+').findall
    links = []
    for m in messages:
        s = m.get_payload()
        links.extend(urlre(s))

    return links


def update_cache(cache, link_end, force=False):
    try:
        os.makedirs(cache)
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise

    for url in get_cvs_links():
        if not url.endswith(link_end):
            continue
        fn = re.sub(r'[^\w.-]+', '+', url[7:])
        ffn = os.path.join(cache, fn)
        if force or not os.path.exists(ffn):
            print >> sys.stderr, "fetching %s" % url
            try:
                r = requests.get(url)
            except requests.ConnectionError as e:
                print >> sys.stderr, "could not fetch '%s': %s" % (url, e)
                continue
            f = open(ffn, 'w')
            f.write(r.text.encode('utf-8'))
            f.close()


def print_all_links():
    for x in get_cvs_links():
        print x


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--print-links', action='store_true',
                        help="print all the autobuild links and exit")

    parser.add_argument('-c', '--count', type=int,
                        help="print this many errors (default all)")

    parser.add_argument('--file-regex', default='',
                        help="look at files matching this regex")

    parser.add_argument('--line-regex', default=None,
                        help="look for lines matching this regex")

    parser.add_argument('--filter-line',
                        help="only look at matched parts of the line")

    parser.add_argument('--since',
                        help=("restrict to filenames containing dates "
                              "> this (YYYY-MM-DD)"))

    parser.add_argument('--until',
                        help=("restrict to filenames containing dates "
                              "< this (YYYY-MM-DD)"))

    parser.add_argument('--histogram', action='store_true',
                        help=("draw a graph of monthly counts"))

    parser.add_argument('--recurring-errors', action='store_true',
                        help=("show errors that occur in many months"))

    parser.add_argument('--has-occurred-since',
                        help=("ignore errors that have not appeared since"
                              "this date"))

    parser.add_argument('--flakey-log', action='store_true',
                        help=("print statistics from flakey.log"))

    parser.add_argument('--stderr', action='store_true',
                        help=("print statistics from stderr logs"))

    parser.add_argument('--run-times', action='store_true',
                        help=("Try and work out the run times"))

    args = parser.parse_args()

    if args.print_links:
        print_all_links()
        sys.exit()

    if args.flakey_log:
        update_cache(FLAKEY_LOG_CACHE, 'flakey.log')
        line_re = args.line_regex or r"\w+: \[\w+\] failed '.+' with status"
        rows = count_lines(fn_re='flakey.log$',
                           line_re=line_re,
                           cache=FLAKEY_LOG_CACHE,
                           count=args.count,
                           since=args.since,
                           until=args.until,
                           filter_re=args.filter_line)
        for k, v in rows:
            print '%4d %s' % (v, k)
        sys.exit()

    if args.line_regex is None:
        args.line_regex = '^UNEXPECTED'

    if args.stderr:
        cache = STDERR_CACHE
        update_cache(cache, '.stderr')
    else:
        cache = STDOUT_CACHE
        update_cache(STDOUT_CACHE, '.stdout')

    if args.has_occurred_since is not None:
        rows = errors_since(fn_re=args.file_regex,
                            line_re=args.line_regex,
                            cache=cache,
                            since=args.has_occurred_since,
                            filter_re=args.filter_line)
        recent = set(x for x, c in rows)
    else:
        recent = None

    if args.run_times:
        draw_runtime_histogram(fn_re=args.file_regex,
                               cache=cache,
                               since=args.since,
                               until=args.until)
        sys.exit()

    if args.histogram:
        draw_histogram(fn_re=args.file_regex,
                       line_re=args.line_regex,
                       cache=cache,
                       since=args.since,
                       until=args.until,
                       filter_re=args.filter_line)
        sys.exit()

    if args.recurring_errors:
        recurring_errors(fn_re=args.file_regex,
                         line_re=args.line_regex,
                         cache=cache,
                         since=args.since,
                         until=args.until,
                         filter_re=args.filter_line,
                         limit=3,
                         included_set=recent)
        sys.exit()

    rows = count_lines(fn_re=args.file_regex,
                       line_re=args.line_regex,
                       cache=cache,
                       count=args.count,
                       since=args.since,
                       until=args.until,
                       filter_re=args.filter_line,
                       included_set=recent)
    for k, v in rows:
        print '%4d %s' % (v, k)


main()
