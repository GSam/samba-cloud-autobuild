#!/usr/bin/python
"""This tool helps you to run performance tests against a number of
branches or revisions and collate the results.

Some tips:

# make a local full mirror of upstream, making subsequent fetches faster:
git clone --mirror git://git.samba.org/samba.git samba-mirror.git

# set the CC variable to something old enough to compile the oldest
# branch you're considering. Newer gcc versions will find more
# warnings that turn into errors with configure.developer's -Werror

# altogether, try something like:

CC=gcc-4.9 ./scripts/multi-perf-test  -o perf-test.json \\
                    -i -r ~/src/samba-mirror.git -t perf_tests -l \\
                    --use-patch-not-git-am
"""
import argparse
import os
import sys
import subprocess
import tempfile
import shutil
import traceback
import json
import re

HERE = os.path.dirname(__file__)

PATCHES = {
    'samba-4-0': [os.path.join(HERE, '../perf/samba-4-0-pidl.patch'),
                  os.path.join(HERE, '../perf/samba-4-0-gnutls.patch'),
                  os.path.join(HERE, '../perf/perf-test.patch'),
                  os.path.join(HERE, '../perf/samba-4.2-perf.patch')],
    'samba-4-2': [os.path.join(HERE, '../perf/perf-test.patch'),
                  os.path.join(HERE, '../perf/samba-4.2-perf.patch')],
    'samba-4-5': [os.path.join(HERE, '../perf/perf-test.patch')],
}


class SambaGitTree(object):

    def __init__(self, path, remote):
        self.path = path
        self.remote = remote
        subprocess.check_call(['git', 'clone', remote, path])
        self.perf_data = {}

    def git(self, *args, **kwargs):
        cmd = ['git', '-C', self.path]
        cmd.extend(args)
        if kwargs.get('output', False):
            return subprocess.check_output(cmd)
        subprocess.check_call(cmd)

    def make(self, *args):
        cmd = ['make', '-C', self.path]
        cmd.extend(args)
        subprocess.check_call(cmd)

    def configure(self, *args):
        # we nust set cwd to self.path AND use the full executable path
        cmd = [os.path.join(self.path, 'configure.developer')]
        cmd.extend(args)
        env = os.environ.copy()
        env['CFLAGS'] = '-Wno-error'
        env['ADDITIONAL_CFLAGS'] = '-Wno-error'
        env['EXTRA_CFLAGS'] = '-Wno-error'
        subprocess.check_call(cmd, cwd=self.path, env=env)

    def checkout(self, tag, clean=False):
        self.git('checkout', tag)
        if clean:
            self.git('clean')

    def build(self):
        self.make('-j')

    def perf_test(self, regex=None):
        if regex is not None:
            self.make('perftest', 'TESTS=%s' % regex)
        else:
            self.make('perftest')

    def list_branches(self, pattern=None):
        # git branch -a | grep -oP 'origin/v4.+-stable'
        # git branch -a --list origin/v4*-stable
        args = ['branch', '-a']
        if pattern is not None:
            args += ['--list', pattern]
        lines = self.git(*args, output=True)
        return lines.split()

    def patch(self, patch, patch_not_am=False, ignore_whitespace=False):
        patch = os.path.abspath(patch)
        if patch_not_am:
            cmd = ['patch', '-d', self.path, '-p1', '-N', '-i', patch]
            if ignore_whitespace:
                cmd.append('--ignore-whitespace')
            subprocess.check_call(cmd)
        elif ignore_whitespace:
            self.git('am', '--ignore-whitespace', '-3', patch)
        else:
            self.git('am', '-3', patch)

    def collect_perf_data(self, tag):
        f = open(os.path.join(self.path, 'st/summary.json'))
        self.perf_data[tag] = json.load(f)
        f.close()

    def write_json(self, f):
        json.dump(self.perf_data, f,
                  sort_keys=True, indent=2, separators=(',', ': '))

    def guess_the_right_patches(self, revision):
        # FIXME: increase cleverness in the face of arbitrary commits
        if re.search(r'4-[0]', revision):
            return PATCHES['samba-4-0']
        if re.search(r'4-[12]', revision):
            return PATCHES['samba-4-2']
        return PATCHES['samba-4-5']


class PerfTestException(Exception):
    pass


def try_and_try_again(interactive, fn, *args, **kwargs):
    while True:
        try:
            fn(*args, **kwargs)
            return
        except Exception:
            if not interactive:
                raise
            print '-' * 72
            traceback.print_exc(file=sys.stdout)
            print '-' * 72
            print "That didn't work."
            print "Hit return to try again (perhaps after ^Z/fg to fix things)"
            print "or type 'q' to skip this step"
            print "or type 'next' to skip this branch"
            x = raw_input("> ")
            if x in 'qQ':
                return
            elif x == 'next':
                raise PerfTestException()


def main():
    parser = argparse.ArgumentParser(description=__doc__,
                        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('branches', nargs='*',
                        help="test these branches/refspecs")
    parser.add_argument('-d', '--working-dir', default=None,
                        help="use this directory (default: a tmpdir)")
    parser.add_argument('--preserve-tmp-dir', action='store_true',
                        help="do not clean up the tmp working directory")
    parser.add_argument('--test-releases', nargs='?',
                        const='origin/v4-[0-9]*-stable',
                        help=("test stable release branches from 4.0 "
                              "(or the supplied pattern)"))
    parser.add_argument('-r', '--remote',
                        default='git://git.samba.org/samba.git',
                        help="git remote to use")
    parser.add_argument('-p', '--patch', action='append',
                        help="apply this patch to each tree")
    parser.add_argument('--no-auto-patch', action='store_true',
                        help="don't try to apply necessary perf test patches")
    parser.add_argument('-i', '--interactive', action='store_true',
                        help="pause when build/patch fails (use ^Z/fg/return)")
    parser.add_argument('--use-patch-not-git-am', action='store_true',
                        help="patch using patch, not git am")
    parser.add_argument('-l', '--ignore-whitespace', action='store_true',
                        help="ignore whitespace differences in patch")
    parser.add_argument('-t', '--test-regex',
                        help="restrict tests with this regex")
    parser.add_argument('-o', '--output', default='samba-performance.json',
                        type=argparse.FileType('w'),
                        help="write data here")

    args = parser.parse_args()

    branches = args.branches
    d = args.working_dir

    try:
        if d is None:
            d = tempfile.mkdtemp()

        print "using directory %r" % d

        tree = SambaGitTree(d, args.remote)

        if args.test_releases:
            branches.extend(tree.list_branches(args.test_releases))

        for b in branches:
            print "trying branch %s in directory %s" % (b, tree.path)
            tree.git('reset', '--hard')
            tree.git('clean')
            tree.checkout(b)
            try:
                patches = []
                if not args.no_auto_patch:
                    patches.extend(tree.guess_the_right_patches(b))
                if args.patch:
                    patches.extend(args.patch)
                for patch in patches:
                    print >> sys.stderr, "using patch %s" % patch
                    try_and_try_again(args.interactive, tree.patch, patch,
                                      args.use_patch_not_git_am,
                                      args.ignore_whitespace)

                try_and_try_again(args.interactive, tree.configure)
                try_and_try_again(args.interactive, tree.build)
            except PerfTestException:
                print "aborting branch %s" % b
                continue
            tree.perf_test(args.test_regex)
            tree.collect_perf_data(b)

    finally:
        tree.write_json(args.output)
        args.output.close()
        if args.working_dir is None and not args.preserve_tmp_dir:
            shutil.rmtree(d)

main()
